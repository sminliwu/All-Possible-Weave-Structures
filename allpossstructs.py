# -*- coding: utf-8 -*-
"""AllPossStructs

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XmA4zrNNq2J4CPTHFK34Q1ApO_8cnas4
"""

def listsMatch(a, b):
  if (a == [] and b == []):
    return True
  elif (a[0] == b[0]):
    return listsMatch(a[1:], b[1:])
  else:
    return False

def factorial(n):
  if (n <= 1): return 1
  else:
    return n * factorial(n-1)

class WeaveStruct:
  def __init__(self, size = 4):
    self.size = size
    self.data = [[-1] * size for x in range(size)]

  def __str__(self):
    printme = ""
    for x in range(self.size):
      printme += "\t" 
      for i in range(self.size):
        if (self.data[x][i] < 0): printme += "-"
        else: printme += str(self.data[x][i])
      printme += "\n"
    return printme
  
  def toString(self):
    res = ""
    for row in range(self.size):
      for col in range(self.size):
        res += str(self.data[row][col])
    return res

  def copy(self):
    ret = WeaveStruct(self.size)
    for row in range(0, self.size):
      for col in range(0, self.size):
        ret.data[row][col] = self.data[row][col]
    return ret

  def row(self, n):
    return self.data[n]

  def col(self, n):
    res = []
    for x in range(self.size):
      res.append(self.data[x][n])
    return res

  def matches(self, w):
    return listsMatch(self.data, w.data)
  
  def unsetAll(self, val = 0):
    res = self.copy()
    for row in range(self.size):
      for x in range(self.size):
        if (self.data[row][x] == val):
          res.data[row][x] = -1
    return res

  # returns a row-shifted copy (shifted down n rows)
  def rowShift(self, n):
    ret = self.copy()
    for i in range(n):
      ret.data.append(ret.data.pop(0))
    return ret

  # returns copy shifted right n rows
  def colShift(self, n):
    return self.rotate().rowShift(n).rotate(self.size - 1)

  # returns a copy rotated 90 degrees CCW N times
  def rotate(self, n = 1):
    x = n % 4
    if (x <= 0): return self.copy()
    else:
      res = WeaveStruct(self.size)
      res.data = []
      for i in range(self.size):
        row = []
        for j in range(self.size):
          row.append(self.data[j][i])

        # print(row)
        res.data.insert(0,row)
      return res.rotate(n-1)

  def isValid(self):
    # if each row & column has at least one interlacement
    for row in self.data:
      # print(row)
      try: row.index(0)
      except: return False
      else:
        try: row.index(1)
        except: return False
    # print(self.rotate().data)
    for col in self.rotate().data:
      # print(col)
      try: col.index(0)
      except: return False
      else:
        try: col.index(1)
        except: return False
    return True

  def isRowShift(self, w):
    s = self.copy()
    for i in range(self.size):
      s = s.rowShift(1)
      if (s.matches(w)): return True
    return False
    # try:
    #   pos = self.data.index(w.data[0])
    #   return w.matches(self.rowShift(pos))
    # except: return False

  def isColShift(self, w):
    return self.rotate().isRowShift(w.rotate())

  def isSomeShift(self, w):
    if (self.isRowShift(w) or self.isColShift(w)):
      return True
    s = self.rowShift(1)
    for i in range(self.size - 1):
      if (s.isColShift(w)): return True
      s = s.rowShift(1)
    return False

  def numFillOptions(self):
    res = 1
    for row in range(self.size):
      for col in range(self.size):
        if (self.data[row][col] < 0): res = res * 2
    return res
  
  def numUnset(self):
    res = 0
    for row in range(self.size):
      for col in range(self.size):
        if (self.data[row][col] < 0): res = res + 1
    return res
  
  def firstUnset(self):
    for row in range(self.size):
      for col in range(self.size):
        if (self.data[row][col] < 0): return [row, col]
  
  def fill(self, row, col, val):
    res = self.copy()
    res.data[row][col] = val
    return res

  def crossFill(self, row, col):
    res = self.copy()
    for r in range(self.size):
      if (r == row):
        res.data[r] = [0] * self.size
        res.data[r][col] = 1
      else:
        res.data[r][col] = 0
    # print(res)
    return res
  
def lineIsFilledWith(list, val):
  if (list[0] == val):
    if (len(list) == 1):
      return True
    else:
      return lineIsFilledWith(list[1:], val)
  else: return False

# assumes all structs in the list are the same size
def printRowOfStructs(structList):
  size = structList[0].size
  printme = ""
  for row in range(size):
    for s in structList:
      printme += "\t" 
      for col in range(size):
        if (s.data[row][col] < 0): printme += "-"
        else: printme += str(s.data[row][col])
    printme += "\n"
  print(printme)
    
def printStructs(structList, width = 6):
  i = 0
  print(str(len(structList)) + " structures:")
  while (len(structList) - i >= width):
    printRowOfStructs(structList[i:i+width])
    i = i + width
    print(i)
  if (i < len(structList)):
    printRowOfStructs(structList[i:])
  # for s in structList:
  #   print(s)
  print(": --- \n\n")

# w = WeaveStruct(4)
# w.data = [[1, 0, 0, 1], [0, 1, 1, 0], [0, 0, 1, 0], [1, 0, 0, 1]]
# print(w)
# x = w.copy()
# x = x.rowShift(1)
# x.data = [[1, 0, 1, 0], [0, -1, 1, 1], [1, 0, 0, -1], [0, 1, 0, 0]]
# print(x)
# x = x.colShift(1).rowShift(2)
# print(x)
# print(x.numFillOptions()) # 2 ^ (num of unset positions)

# # print(listsMatch([[2,0,0], [1, 1, 1], [2, 1, 0]],[[2,0,0], [1, 1, 1], [2, 1, 0]]))
# print(w.isRowShift(x))
# print(w.isValid())

# print(x.isSomeShift(w))

# x = x.rotate()
# w = w.rotate()
# printStructs([w, x])
# print(x.isRowShift(w))
# print(x.rotate(2))

class StructDictEntry:
  def __init__(self, struct, id):
    self.struct = struct
    self.id = id
    self.rots = []
    self.shifts = []

class StructDict:
  def __init__(self, size = 4):
    self.data = {} # entry format: { 'stringrep': { struct: WeaveStruct, id: num (dict length), rots: [id nums], shifts: [string reps] }}
    self.rots = {}
    self.shifts = {}
    self.size = size
    self.counter = 0
    self.duplicates = 0

    # self.minTwill(self.size)
    # print(self.data)

  def __str__(self):
    printme = ""
    for id in self.data:
      entry = self.data[id]
      printme += str(entry.id) + "|" + str(id) + ": \n" + str(entry.struct)
    return printme

  def minTwill(self, size):
    curr = WeaveStruct(size)

    for i in range(size):
      curr.data[i] = [0] * size
      curr.data[i][i] = 1
    self.data[curr.toString()] = curr.copy()
    self.counter = self.counter + 1

  def add(self, struct):
    # print(struct)
    newKey = struct.toString()
    try: self.data[newKey]
    except: # there is no entry with this string rep
      # print("not a duplicate")
      try: self.shifts[newKey] # already generated as a shift?
      except:
        # isShift = False
        # for key in self.data:
        #   s = self.data[key]
        #   if (struct.isSomeShift(s.struct)):
        #     isShift = True
        #     # print(struct.toString() + " is shift of " + str(s.id))
        #     self.shifts[newKey] = StructDictEntry(struct, s.id)
        #     break
        # if (not isShift):
        newId = len(self.data)
        self.data[newKey] = StructDictEntry(struct, len(self.data))
        for i in range(self.size):
          for j in range(self.size):
            w = struct.rowShift(i).colShift(j)
            self.shifts[w.toString()] = StructDictEntry(w, newId)
      self.counter = self.counter + 1
    else: 
      # print("is duplicate")
      self.duplicates = self.duplicates + 1


def fillMinBindings(size):
  res = [WeaveStruct(size)]
  # res[0] = res[0].crossFill(0,0)
  # print(res[0].crossFill(1,1))

  for i in range(size):
    print("pass " + str(i))
    # printStructs(res)
    newRes = []
    # print(id(newRes))
    for s in range(len(res)):
      # options = []
      for cell in range(size):
        # res[s].row(i)
        # print(res[s])
        if (res[s].row(i)[cell] < 0): # if this cell hasn't yet been filled in
          newRes.append(res[s].crossFill(i, cell))
      # printStructs(options)
      # newRes.extend(options)
      # printStructs(newRes)
    res = newRes.copy()

  # print("finished")
  # print(len(res))
  # printStructs(res)
  return res

def allPossFills(struct):
  count = struct.numUnset()
  allPoss = [struct.copy()]
  # if (count <= 0): return allPoss # all filled in, we're done
  # else:
  lastIdx = struct.size - 1
  while (count > 0):
    print(str(count) + " cells left")
    [row, col] = allPoss[0].firstUnset()
    # print([row, col])
    # print(len(allPoss))
    newPoss = []
    for s in allPoss: 
      if (row == lastIdx and col == lastIdx):
        if (not (lineIsFilledWith(s.row(row)[:lastIdx], 0) and lineIsFilledWith(s.col(col)[:lastIdx], 0))):
          newPoss.append(s.fill(row, col, 0))
        if (not (lineIsFilledWith(s.row(row)[:lastIdx], 1) and lineIsFilledWith(s.col(col)[:lastIdx], 1))):
          newPoss.append(s.fill(row, col, 1))
      elif (col == lastIdx):
        if (not lineIsFilledWith(s.row(row)[:lastIdx], 0)):
          newPoss.append(s.fill(row, col, 0))
        if (not lineIsFilledWith(s.row(row)[:lastIdx], 1)):
          newPoss.append(s.fill(row, col, 1))
      elif (row == lastIdx):
        if (not lineIsFilledWith(s.col(col)[:lastIdx], 0)):
          newPoss.append(s.fill(row, col, 0))
        if (not lineIsFilledWith(s.col(col)[:lastIdx], 1)):
          newPoss.append(s.fill(row, col, 1))
      else:
        newPoss.append(s.fill(row, col, 0))
        newPoss.append(s.fill(row, col, 1))
    # printStructs(newPoss, 12)
    allPoss = newPoss.copy()
    count = count - 1
    # return allPossFills(newPoss[0]).extend(allPossFills(newPoss[1]))
  print(len(allPoss))
  return allPoss

def categorizeFills(poss):
  res = StructDict(poss[0].size)
  length = len(poss)
  # for struct in min:
  #   # register in dictionary
  #   if (struct.isValid()):
  #     res.add(struct)
  for struct in poss:
    # register in dictionary
    if (struct.isValid()):
      res.add(struct)

    count = res.counter + res.duplicates
    if (count % 100 == 0):
      print(str(count) + "/" + str(length))

  print(res)
  # print("shifts")
  # for key in res.shifts:
  #   print(key + ": " + str(res.shifts[key].id))

  print(str(res.duplicates) + " duplicates filtered")
  print(str(res.counter) + " structures registered")
  print(str(len(res.data)) + " unique weaves")


# script starts here
SIZE = 4
minStructs = fillMinBindings(SIZE)
printRowOfStructs(minStructs)
# unsetTwill = minStructs[0].unsetAll()
print("FILLING")
# print(unsetTwill)
# print(unsetTwill.numFillOptions())

# route = False

# if (route):
#   allFills = []
#   for s in minStructs:
#     # print(s)
#     allFills.extend(allPossFills(s.unsetAll()))
#     # print(len(allFills))
# else:
allFills = allPossFills(WeaveStruct(SIZE))

allFills = list(filter(lambda x: x.isValid(), allFills))
print("filtered invalid: " + str(len(allFills)) + " structures")

allFills.sort(key=lambda x: (x.toString()))

printStructs(allFills, 8)
# allFills = list(filter(lambda x: (allFills.count(x) > 1), allFills))
# print("filtered duplicates: " + str(len(allFills)) + " structures")
# printStructs(allFills, 14)
  # printStructs(allPossFills(s.unsetAll()), 12)
categorizeFills(allFills)